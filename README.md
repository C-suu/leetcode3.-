# leetcode3. 无重复字符的最长子串 给定一个字符串 s ，请你找出其中不含有重复字符的 最长 子串 的长度。

## 解题逻辑：用一段“始终没有重复字符的连续窗口”，在字符串上从左到右滑动，记录这个窗口能达到的最大长度。

---

## 一、题目目标（用大白话说）

👉 给一个字符串（比如 `"abcabcbb"`），
👉 在**连续的一段字符**中，
👉 找到 **没有任何重复字符** 的 **最长那一段**，
👉 返回 **这段的长度（数字）**。

⚠️ 注意：

* **子串 = 必须连续**
* 不是随便挑字符（那叫子序列）

---

## 二、最终答案（Python 代码）

下面是**标准最优解（时间复杂度 O(n)）**

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:     # 定义一个函数，名字叫 lengthOfLongestSubstring，参数是字符串 s
        char_set = set()                      # 创建一个集合，用来存放当前子串里的字符
        left = 0                              # 左指针，表示子串的左边界
        max_len = 0                           # 记录目前找到的最大长度

        for right in range(len(s)):           # 右指针从 0 遍历到字符串末尾，也可以加上`right = 0`的代码
            while s[right] in char_set:       # 如果右指针指向的字符已经出现过
                char_set.remove(s[left])      # 把左指针指向的字符从集合中移除
                left += 1                     # 左指针右移一位
            char_set.add(s[right])            # 把当前字符加入集合
            max_len = max(max_len, right - left + 1)  # 更新最大长度

        return max_len                        # 返回最终结果
```

---

## 三、逐行解释（**每一行代码都讲清楚**）

### 第 1 行

```python
def lengthOfLongestSubstring(s):
```

> 定义一个函数，用来计算字符串 `s` 中最长无重复子串的长度

---

### 第 2 行

```python
char_set = set()
```

* `set()`：**集合**
* 集合特点：

  * 里面的元素 **不能重复**
  * 查找速度非常快

📌 用途：

> 用来保存“当前子串中已经出现的字符”

---

### 第 3 行

```python
left = 0
```

* `left`：左指针
* 表示当前子串的 **起始位置**

📌 举例：
如果子串是 `s[2:5]`，那 `left = 2`

---

### 第 4 行

```python
max_len = 0
```

* `max_len`：记录**最长无重复子串的长度**
* 初始为 0（什么都没找到）

---

### 第 6 行

```python
for right in range(len(s)):
```

* `right`：右指针
* `range(len(s))`：从 `0` 到字符串最后一个字符

📌 意思：

> 右指针一步一步往右走，尝试扩展子串

---

### 第 7 行（最关键）

```python
while s[right] in char_set:
```

* `s[right]`：右指针当前指向的字符
* `in`：判断是否在集合中
* `while`：只要条件成立，就一直执行

📌 意思：

> **如果出现重复字符，就必须缩小左边界**

---

### 第 8 行

```python
char_set.remove(s[left])
```

* 把 **左指针指向的字符** 从集合中删掉

📌 原因：

> 要把重复字符“踢出去”

---

### 第 9 行

```python
left += 1
```

* 左指针右移一位
* 子串向右“收缩”

---

### 第 10 行

```python
char_set.add(s[right])
```

* 把当前右指针的字符加入集合

📌 现在子串是“没有重复字符的”

---

### 第 11 行

```python
max_len = max(max_len, right - left + 1)
```

* `right - left + 1`：
  👉 当前子串长度
* `max()`：取更大的那个

📌 意思：

> 更新最长长度记录

---

### 第 13 行

```python
return max_len
```

* 返回最终答案

---

## 四、数值示例详解（s = `"pwwkew"`）

### 初始状态

| 变量       | 值    |
| -------- | ---- |
| left     | 0    |
| char_set | `{}` |
| max_len  | 0    |

---

### 过程变化表（非常重要）

| 步骤 | right | s[right] | char_set | left | 当前子串  | max_len |
| -- | ----- | -------- | -------- | ---- | ----- | ------- |
| 1  | 0     | p        | {p}      | 0    | "p"   | 1       |
| 2  | 1     | w        | {p,w}    | 0    | "pw"  | 2       |
| 3  | 2     | w        | 重复！      | 1    | "w"   | 2       |
| 4  | 3     | k        | {w,k}    | 2    | "wk"  | 2       |
| 5  | 4     | e        | {w,k,e}  | 2    | "wke" | 3       |
| 6  | 5     | w        | 重复！      | 3    | "kew" | 3       |

---

### 最终答案

```text
3
```

因为最长无重复子串是 `"wke"`

---

## 五、一句话总结（给小白看的）

> 👉 用 **两个指针** 控制一段连续子串
> 👉 用 **集合** 保证字符不重复
> 👉 右边扩展，左边收缩
> 👉 一次遍历就能解决问题（O(n)）

---

如果愿意，下一步可以帮：

* 🌱 用**生活例子**再讲一遍
* 🧠 用**动画思路**讲指针怎么动
* 🧪 把代码改成“每一步都打印出来”的版本

想选哪一个？
