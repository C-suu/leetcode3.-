# leetcode3. 无重复字符的最长子串 给定一个字符串 s ，请找出其中不含有重复字符的 最长 子串 的长度。

## 解题逻辑：用一段“始终没有重复字符的连续窗口”，在字符串上从左到右滑动，记录这个窗口能达到的最大长度。

---

## 一、题目目标（用大白话说）

👉 给一个字符串（比如 `"abcabcbb"`），
👉 在**连续的一段字符**中，
👉 找到 **没有任何重复字符** 的 **最长那一段**，
👉 返回 **这段的长度（数字）**。

⚠️ 注意：

* **子串 = 必须连续**
* 不是随便挑字符（那叫子序列）

---

## 二、最终答案（Python 代码）

下面是**标准最优解（时间复杂度 O(n)）**

```python
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:     # 定义一个函数，名字叫 lengthOfLongestSubstring，参数是字符串 s
        char_set = set()                      # 创建一个集合，用来存放当前子串里的字符
        left = 0                              # 左指针，表示子串的左边界
        max_len = 0                           # 记录目前找到的最大长度

        for right in range(len(s)):           # 右指针从 0 遍历到字符串末尾，也可以加上`right = 0`的代码
            while s[right] in char_set:       # 如果右指针指向的字符已经出现过
                char_set.remove(s[left])      # 把左指针指向的字符从集合中移除
                left += 1                     # 左指针右移一位
            char_set.add(s[right])            # 把当前字符加入集合
            max_len = max(max_len, right - left + 1)  # 更新最大长度
            max_len = max(max_len, len(char_set)) # 如果写 len(char_set)，也可以；但写 right - left + 1 是滑动窗口的标准定义公式。

        return max_len                        # 返回最终结果
```

---

## 三、逐行解释（**每一行代码都讲清楚**）

### 第 1 行

```python
def lengthOfLongestSubstring(s):
```

> 定义一个函数，用来计算字符串 `s` 中最长无重复子串的长度

---

### 第 2 行

```python
char_set = set()
```

* `set()`：**集合**
* 集合特点：

  * 里面的元素 **不能重复**
  * 查找速度非常快

📌 用途：

> 用来保存“当前子串中已经出现的字符”

---

### 第 3 行

```python
left = 0
```

* `left`：左指针
* 表示当前子串的 **起始位置**

📌 举例：
如果子串是 `s[2:5]`，那 `left = 2`

---

### 第 4 行

```python
max_len = 0
```

* `max_len`：记录**最长无重复子串的长度**
* 初始为 0（什么都没找到）

---

### 第 6 行

```python
for right in range(len(s)):
```

* `right`：右指针
* `range(len(s))`：从 `0` 到字符串最后一个字符

📌 意思：

> 右指针一步一步往右走，尝试扩展子串

---

### 第 7 行（最关键）

```python
while s[right] in char_set:
```

* `s[right]`：右指针当前指向的字符
* `in`：判断是否在集合中
* `while`：只要条件成立，就一直执行

📌 意思：

> **如果出现重复字符，就必须缩小左边界**

---

### 第 8 行

```python
char_set.remove(s[left])
```

* 把 **左指针指向的字符** 从集合中删掉

📌 原因：

> 要把重复字符“踢出去”

---

### 第 9 行

```python
left += 1
```

* 左指针右移一位
* 子串向右“收缩”

---

### 第 10 行

```python
char_set.add(s[right])
```

* 把当前右指针的字符加入集合

📌 现在子串是“没有重复字符的”

---

### 第 11 行

```python
max_len = max(max_len, right - left + 1)
```

* `right - left + 1`：
  👉 当前子串长度
* `max()`：取更大的那个

📌 意思：

> 更新最长长度记录
> 为何是“ right - left + 1”？
> right - left + 1 的本质含义是：
👉 当前“合法滑动窗口”中，一共有多少个字符。

从 索引 1 数到 索引 3，一共有多少个？索引 1 → 2 → 3，一共 3 个。

数学上这是怎么算的？
很多人第一反应是：
3 - 1 = 2   ❌
但这是间隔数，不是元素个数。
正确的公式是：

`元素个数 = 右端点 - 左端点 + 1`

因为：两端 都要算，所以要 +1

---

### 第 13 行

```python
return max_len
```

* 返回最终答案

---

## 四、数值示例详解（s = `"pwwkew"`）

### 初始状态

| 变量       | 值    |
| -------- | ---- |
| left     | 0    |
| char_set | `{}` |
| max_len  | 0    |

---

### 过程变化表（非常重要）

| 步骤 | right | s[right] | char_set | left | 当前子串  | max_len |
| -- | ----- | -------- | -------- | ---- | ----- | ------- |
| 1  | 0     | p        | {p}      | 0    | "p"   | 1       |
| 2  | 1     | w        | {p,w}    | 0    | "pw"  | 2       |
| 3  | 2     | w        | 重复！      | 1    | "w"   | 2       |
| 4  | 3     | k        | {w,k}    | 2    | "wk"  | 2       |
| 5  | 4     | e        | {w,k,e}  | 2    | "wke" | 3       |
| 6  | 5     | w        | 重复！      | 3    | "kew" | 3       |

---

### 最终答案

```text
3
```

因为最长无重复子串是 `"wke"`

---

## 对于上述的过程变化表，问题是：`right = 2`的时候，w重复，则此时触发`while s[right] in char_set:`循环，即`char_set.remove(s[left])`和`left += 1`，但是移除的`s[left]`不应该是p吗？因为left是0，为何到`right = 3`的时候当前子串变成了`w`一个？还有，滑动窗口是如何定义子串？比如left是1，right是2，那么此时应该是`ww`，因为都对应了`w`，为何此时写的当前子串仅是`w`一个而不是`ww`？因为滑动窗口left不算，right算，类似数学的`(]`？

这个问题问得**非常非常好**，而且已经触及了这道题**90% 初学者都会混淆的核心点**。
们来**逐层把这个“误解”彻底拆掉**。

---

## 一、先给结论（非常重要）

> **滑动窗口里的“子串”，不是由下标 `[left, right]` 直接“读出来”的，而是由：
> 👉「窗口规则 + 集合内容」共同定义的。**

**`left` 和 `right` 不是在“描述一个固定区间”，而是在“维护一个约束成立的状态”。**

---

## 二、提出的第一个关键疑问

> `right = 2` 时，`w` 重复
> `left = 0`，所以 `remove(s[left])` 移除的不是 `p` 吗？
> 那为什么后面“当前子串”只剩一个 `w`？

这个疑问 **完全正确**，们来**逐行“真实执行”一次**。

---

## 三、严格模拟 `s = "pwwkew"` 在 `right = 2` 时发生的事

### 初始状态（right = 1 之后）

字符序列：

```
索引:  0   1   2
字符:  p   w   w
```

当前状态是：

| 变量       | 值      |
| -------- | ------ |
| left     | 0      |
| right    | 1      |
| char_set | {p, w} |
| 当前合法子串   | "pw"   |

---

## 四、现在进入关键时刻：`right = 2`

### 1️⃣ right 指向的字符是

```python
s[2] = 'w'
```

👉 `'w'` **已经在 `char_set` 里了**

---

## 五、`while s[right] in char_set` 是一个「循环」，不是一步！

### 🔁 第一次进入 while

#### 当前状态

```
left = 0
char_set = {p, w}
```

执行：

```python
char_set.remove(s[left])  # remove 'p'
left += 1                 # left = 1
```

现在：

```
char_set = {w}
left = 1
```

⚠️ 注意：
**此时 `'w'` 仍然在 `char_set` 中**
👉 所以 `while` 还要继续！

---

### 🔁 第二次进入 while

现在：

```
s[right] = 'w'
char_set = {w}
```

仍然满足条件！

执行：

```python
char_set.remove(s[left])  # remove 'w'
left += 1                 # left = 2
```

现在：

```
char_set = {}
left = 2
```

---

### ✅ 现在跳出 while

因为：

```
'w' 不在 char_set 中
```

---

### ➕ 把当前字符加入

```python
char_set.add('w')
```

最终状态：

| 变量       | 值     |
| -------- | ----- |
| left     | 2     |
| right    | 2     |
| char_set | {'w'} |

---

## 六、这就是为什么“当前子串”是 `"w"` 而不是 `"pw"` 或 `"ww"`

👉 因为：

* `p` 被移除了（第一次 while）
* 旧的 `w` 也被移除了（第二次 while）
* 只保留了 **最新的、合法的 `w`**

---

## 七、第二个问题：滑动窗口是怎么“定义子串”的？

问得非常精准 👇

> 如果 `left = 1`，`right = 2`，
> 那不是 `s[1:2] = "ww"` 吗？

### ❌ 错误理解（这是大多数人的直觉）

> 滑动窗口 = 字符串切片 `[left, right]`

### ✅ 正确理解（这是算法真正的含义）

> **滑动窗口 =
> 满足“无重复”规则的、由代码动态维护的一组字符**

也就是说：

* `left` 和 `right` **不是用来“直接读字符串”的**
* 它们只是：

  * `right`：正在尝试加入的新字符
  * `left`：为了维持规则，不得不丢掉字符的位置

---

## 八、所以：滑动窗口不是数学区间 `(]` 或 `[]`

❌ 它 **不是**：

* `(left, right]`
* `[left, right)`

✅ 它是：

> **一个“逻辑窗口”**
> **由规则（无重复）决定内容**

窗口的真实内容，**等价于 `char_set` 中的字符顺序版本**，
而不是简单的 `s[left:right+1]`。

---

## 九、用一句非常关键的话总结

> **`left` 的作用不是“定义子串边界”，
> 而是“修复非法状态，直到规则再次成立”。**

---

## 十、再给一个“彻底防混淆”的心智模型

### ✅ 正确心智模型（请记住这个）

* `right`：
  👉 想把这个字符加入“合法集合”
* 如果违法（重复）：
  👉 就不断让 `left` 删除旧字符
* 直到：
  👉 新字符 **可以合法加入**
* 当前子串：
  👉 就是 **“最近的一段无重复字符历史”**

---

## 一句话总结

> 👉 用 **两个指针** 控制一段连续子串
> 👉 用 **集合** 保证字符不重复
> 👉 右边扩展，左边收缩
> 👉 一次遍历就能解决问题（O(n)）

---

